const fs = require("fs");
const { ethers, BigNumber } = require("ethers");

const truffleAssert = require("truffle-assertions");

const CustomERC20 = artifacts.require("./CustomERC20.sol");
const PablockToken = artifacts.require("./PablockToken.sol");

const { getPermitDigest, getTransferDigest, sign } = require("../utility");

const privateKeys = require("../ganachePrivateKeys.json");

const deadline = 1657121546000;

contract("Custom ERC20", async (accounts) => {
  it("should set allowance after a permit transaction", async () => {
    const pablockTokenInstance = await PablockToken.deployed();
    const customERC20Instance = await CustomERC20.deployed();

    await pablockTokenInstance.requestToken(accounts[1], 10);
    await pablockTokenInstance.addContractToWhitelist(
      customERC20Instance.address
    );

    const value = 100;

    const approve = {
      owner: accounts[1],
      spender: accounts[2],
      value,
    };

    const nonce = parseInt(
      (await customERC20Instance.getNonces(approve.owner)).toString()
    );

    const digest = getPermitDigest(
      await customERC20Instance.name(),
      customERC20Instance.address,
      parseInt((await customERC20Instance.getChainId()).toString()),
      approve,
      nonce,
      deadline
    );

    // Sign it
    // NOTE: Using web3.eth.sign will hash the message internally again which
    // we do not want, so we're manually signing here
    const { v, r, s } = sign(digest, Buffer.from(privateKeys[1], "hex"));

    await customERC20Instance.requestPermit(
      approve.owner,
      approve.spender,
      approve.value,
      deadline,
      v,
      r,
      s,
      { from: accounts[0] }
    );

    let allowance = (
      await customERC20Instance.allowance(accounts[1], accounts[2])
    ).toString();

    assert.equal(allowance, "100", "Allowance is set at 100");
  });
  it("Should mint token", async function () {
    const customERC20Instance = await CustomERC20.deployed();

    await customERC20Instance.mint(accounts[0], 1000);
    await customERC20Instance.mint(accounts[1], 1000);

    let balance = (await customERC20Instance.balanceOf(accounts[1])).toString();

    assert.equal(balance, "1000", "1000 token minted");
  });
  it("Should send token", async function () {
    const customERC20Instance = await CustomERC20.deployed();

    await customERC20Instance.transferFrom(accounts[0], accounts[1], 1000, {
      from: accounts[0],
    });

    let balance = (await customERC20Instance.balanceOf(accounts[1])).toString();

    assert.equal(balance, "2000", "2000 token minted");
  });

  it("Should not send token", async function () {
    const customERC20Instance = await CustomERC20.deployed();

    truffleAssert.reverts(
      customERC20Instance.transferFrom(accounts[1], accounts[0], 1000, {
        from: accounts[1],
      }),
      "Address not allowed"
    );
  });
  it("should allow transfer", async () => {
    const pablockTokenInstance = await PablockToken.deployed();
    const customERC20Instance = await CustomERC20.deployed();

    //Transfer from accounts[2] to accounts[1] after accounts[2] give permit to accounts[1] to spend his tokens
    const transfer = {
      from: accounts[1],
      to: accounts[2],
      amount: 10,
    };

    const nonce = parseInt(
      (await customERC20Instance.getNonces(accounts[2])).toString()
    );

    const digest = getTransferDigest(
      await customERC20Instance.name(),
      customERC20Instance.address,
      parseInt((await customERC20Instance.getChainId()).toString()),
      transfer,
      nonce
    );

    const { v, r, s } = sign(digest, Buffer.from(privateKeys[2], "hex"));

    await customERC20Instance.transferToken(
      transfer.from,
      transfer.to,
      accounts[2],
      transfer.amount,
      v,
      r,
      s
    );
    let balance = (await customERC20Instance.balanceOf(accounts[2])).toString();

    assert.equal(balance, "10", "transfer 100 token");
  });
});
